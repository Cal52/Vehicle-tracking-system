# -*- coding: utf-8 -*-
"""Vehicletrackpro.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p6TqUaS9FafLLOb_R88bvbdqelNKqFF9
"""

import uuid
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, List
from datetime import datetime, timedelta
import pandas as pd
import matplotlib.pyplot as plt

class VehicleType(Enum):
    SEDAN = auto()
    SUV = auto()
    TRUCK = auto()
    VAN = auto()

class VehicleStatus(Enum):
    IN_STORE = auto()
    OUT_FOR_DELIVERY = auto()
    MAINTENANCE = auto()
    UNDER_REPAIR = auto()

@dataclass
class Vehicle:
    vehicle_type: VehicleType
    license_plate: str
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    current_status: VehicleStatus = VehicleStatus.IN_STORE

    # Cost-related attributes
    purchase_cost: float = 0.0
    maintenance_cost: float = 0.0
    fuel_cost: float = 0.0
    insurance_cost: float = 0.0

    # Vehicle-specific details
    mileage: float = 0.0
    total_trips: int = 0
    total_distance: float = 0.0
    last_maintenance_date: datetime = field(default_factory=datetime.now)

class ParkingLot:
    def __init__(self, total_spots: int):
        self.total_spots = total_spots
        self.occupied_spots = 0  # Start with 0 occupied spots
        self.parking_rates = {
            VehicleType.SEDAN: 50,  # hourly parking rate
            VehicleType.SUV: 75,
            VehicleType.TRUCK: 100,
            VehicleType.VAN: 85
        }

    def park_vehicle(self, vehicle_type: VehicleType):
        if self.occupied_spots < self.total_spots:
            self.occupied_spots += 1
            return True
        return False

    def remove_vehicle(self):
        if self.occupied_spots > 0:
            self.occupied_spots -= 1
            return True
        return False

    def get_vacant_spots(self):
        return self.total_spots - self.occupied_spots

    def calculate_parking_fee(self, vehicle_type: VehicleType, hours: float):
        return self.parking_rates[vehicle_type] * hours

class VehicleTrackingSystem:
    def __init__(self, total_parking_spots: int):
        self.vehicles: Dict[str, Vehicle] = {}
        self.parking_lot = ParkingLot(total_parking_spots)
        self.total_fleet_cost = 0.0

    def add_vehicle(self, vehicle_type: VehicleType, license_plate: str,
                    purchase_cost: float, insurance_cost: float):
        vehicle = Vehicle(
            vehicle_type=vehicle_type,
            license_plate=license_plate,
            purchase_cost=purchase_cost,
            insurance_cost=insurance_cost
        )
        self.vehicles[vehicle.id] = vehicle
        self.total_fleet_cost += purchase_cost + insurance_cost
        # Automatically park the vehicle when added
        self.parking_lot.park_vehicle(vehicle_type)
        return vehicle





    def dispatch_vehicle(self, vehicle_id: str, distance: float):
        vehicle = self.vehicles.get(vehicle_id)
        if not vehicle or vehicle.current_status != VehicleStatus.IN_STORE:
            raise ValueError("Vehicle not available")

        # Check parking availability
        if not self.parking_lot.remove_vehicle():
            raise ValueError("No parking spot available to dispatch vehicle")

        # Update vehicle status and metrics
        vehicle.current_status = VehicleStatus.OUT_FOR_DELIVERY
        vehicle.total_trips += 1
        vehicle.total_distance += distance

        # Estimate fuel cost (assuming 10 km/l and fuel price of â‚¹100 per liter)
        vehicle.fuel_cost += (distance / 10) * 100

        return vehicle

    def return_vehicle(self, vehicle_id: str):
        vehicle = self.vehicles.get(vehicle_id)
        if not vehicle or vehicle.current_status != VehicleStatus.OUT_FOR_DELIVERY:
            raise ValueError("Invalid vehicle status")

        # Park the vehicle
        self.parking_lot.park_vehicle(vehicle.vehicle_type)

        # Update status
        vehicle.current_status = VehicleStatus.IN_STORE

        return vehicle

    def record_maintenance(self, vehicle_id: str, maintenance_cost: float):
        vehicle = self.vehicles.get(vehicle_id)
        if vehicle:
            vehicle.maintenance_cost += maintenance_cost
            vehicle.last_maintenance_date = datetime.now()
            vehicle.current_status = VehicleStatus.MAINTENANCE
            self.total_fleet_cost += maintenance_cost

    def generate_fleet_report(self):
        report_data = []
        for vehicle in self.vehicles.values():
            report_data.append({
                'Vehicle ID': vehicle.id,
                'License Plate': vehicle.license_plate,
                'Type': vehicle.vehicle_type.name,
                'Status': vehicle.current_status.name,
                'Total Trips': vehicle.total_trips,
                'Total Distance': vehicle.total_distance,
                'Purchase Cost': vehicle.purchase_cost,
                'Maintenance Cost': vehicle.maintenance_cost,
                'Fuel Cost': vehicle.fuel_cost,
                'Insurance Cost': vehicle.insurance_cost
            })

        return pd.DataFrame(report_data)

    def visualize_fleet_metrics(self):
        df = self.generate_fleet_report()

        plt.figure(figsize=(15, 10))

        # Vehicle Status Distribution
        plt.subplot(2, 2, 1)
        df['Status'].value_counts().plot(kind='pie', autopct='%1.1f%%')
        plt.title('Vehicle Status Distribution')

        # Costs by Vehicle Type
        plt.subplot(2, 2, 2)
        df.groupby('Type')[['Purchase Cost', 'Maintenance Cost', 'Fuel Cost']].sum().plot(kind='bar')
        plt.title('Costs by Vehicle Type')
        plt.xticks(rotation=45)

        # Total Trips by Vehicle Type
        plt.subplot(2, 2, 3)
        df.groupby('Type')['Total Trips'].sum().plot(kind='bar')
        plt.title('Total Trips by Vehicle Type')
        plt.xticks(rotation=45)

        # Total Distance by Vehicle Type
        plt.subplot(2, 2, 4)
        df.groupby('Type')['Total Distance'].sum().plot(kind='bar')
        plt.title('Total Distance by Vehicle Type')
        plt.xticks(rotation=45)

        plt.tight_layout()
        plt.show()

def main():
    # Initialize Vehicle Tracking System with 50 parking spots
    tracking_system = VehicleTrackingSystem(total_parking_spots=50)

    # Add vehicles to the fleet
    sedan1 = tracking_system.add_vehicle(
        VehicleType.SEDAN, "MH01AB1234",
        purchase_cost=1000000, insurance_cost=50000
    )
    suv1 = tracking_system.add_vehicle(
        VehicleType.SUV, "KA02CD5678",
        purchase_cost=1500000, insurance_cost=75000
    )
    truck1 = tracking_system.add_vehicle(
        VehicleType.TRUCK, "DL03EF9101",
        purchase_cost=2000000, insurance_cost=100000
    )

    # Simulate vehicle dispatches and returns
    tracking_system.dispatch_vehicle(sedan1.id, distance=50.5)
    tracking_system.return_vehicle(sedan1.id)

    tracking_system.dispatch_vehicle(suv1.id, distance=75.2)
    tracking_system.return_vehicle(suv1.id)

    # Record maintenance
    tracking_system.record_maintenance(truck1.id, maintenance_cost=25000)

    # Generate and print fleet report
    fleet_report = tracking_system.generate_fleet_report()
    print("Fleet Performance Report:")
    print(fleet_report)

    # Visualize fleet metrics
    tracking_system.visualize_fleet_metrics()

    # Check parking lot status
    print(f"\nVacant Parking Spots: {tracking_system.parking_lot.get_vacant_spots()}")

if __name__ == "__main__":
    main()

!pip install gradio

import gradio as gr
import pandas as pd



def create_interface():
    # Create tracking system
    tracking_system = VehicleTrackingSystem(total_parking_spots=50)

    # Add some sample vehicles
    sedan1 = tracking_system.add_vehicle(
        VehicleType.SEDAN, "MH01AB1234",
        purchase_cost=1000000, insurance_cost=50000
    )
    suv1 = tracking_system.add_vehicle(
        VehicleType.SUV, "KA02CD5678",
        purchase_cost=1500000, insurance_cost=75000
    )

    def add_vehicle(vehicle_type, license_plate, purchase_cost, insurance_cost):
        vehicle = tracking_system.add_vehicle(
            VehicleType[vehicle_type],
            license_plate,
            purchase_cost,
            insurance_cost
        )
        return f"Vehicle added successfully. ID: {vehicle.id}"

    def dispatch_vehicle(vehicle_id, distance):
        try:
            vehicle = tracking_system.dispatch_vehicle(vehicle_id, distance)
            return f"Vehicle {vehicle.license_plate} dispatched successfully"
        except Exception as e:
            return str(e)

    def return_vehicle(vehicle_id):
        try:
            vehicle = tracking_system.return_vehicle(vehicle_id)
            return f"Vehicle {vehicle.license_plate} returned successfully"
        except Exception as e:
            return str(e)

    def get_fleet_report():
        report = tracking_system.generate_fleet_report()
        return report.to_string()


    with gr.Blocks() as demo:
        gr.Markdown("# Vehicle Tracking System")

        with gr.Tab("Add Vehicle"):
            vehicle_type = gr.Dropdown(choices=[vtype.name for vtype in VehicleType], label="Vehicle Type")
            license_plate = gr.Textbox(label="License Plate")
            purchase_cost = gr.Number(label="Purchase Cost")
            insurance_cost = gr.Number(label="Insurance Cost")
            add_btn = gr.Button("Add Vehicle")
            output = gr.Textbox(label="Result")

            add_btn.click(
                add_vehicle,
                inputs=[vehicle_type, license_plate, purchase_cost, insurance_cost],
                outputs=output
            )

        with gr.Tab("Dispatch Vehicle"):
            vehicle_id = gr.Textbox(label="Vehicle ID")
            distance = gr.Number(label="Distance")
            dispatch_btn = gr.Button("Dispatch Vehicle")
            dispatch_output = gr.Textbox(label="Result")

            dispatch_btn.click(
                dispatch_vehicle,
                inputs=[vehicle_id, distance],
                outputs=dispatch_output
            )

        with gr.Tab("Return Vehicle"):
            return_vehicle_id = gr.Textbox(label="Vehicle ID")
            return_btn = gr.Button("Return Vehicle")
            return_output = gr.Textbox(label="Result")

            return_btn.click(
                return_vehicle,
                inputs=return_vehicle_id,
                outputs=return_output
            )

        with gr.Tab("Fleet Report"):
            report_btn = gr.Button("Generate Report")
            report_output = gr.Textbox(label="Fleet Report")

            report_btn.click(get_fleet_report, outputs=report_output)

    return demo

# Launch the interface
demo = create_interface()
demo.launch(share=True)

